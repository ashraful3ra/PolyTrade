let symbolsCache = [];
let selectedCoins = new Map();
let runningTrades = new Map(); // Stores real-time trade data
let socket = null;
let tomSelect = null;

// --- Helper Functions ---
function el(tag, attrs = {}) {
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
    return e;
}

function showError(msg, selector = '#trade-setup-error') {
    const errorDiv = document.querySelector(selector);
    errorDiv.textContent = msg;
    errorDiv.style.display = 'block';
    setTimeout(() => errorDiv.style.display = 'none', 5000);
}

// --- Coin Settings Management ---
function addCoin(symbol) {
    if (selectedCoins.has(symbol)) return;
    const coinData = { symbol, leverage: 10, margin: 100, price: 'Loading...' };
    selectedCoins.set(symbol, coinData);
    renderCoinSettings();
    fetch(`/api/price?symbol=${symbol}`).then(r => r.json()).then(d => {
        if (d.price) {
            coinData.price = parseFloat(d.price);
            renderCoinSettings();
        }
    });
}

function removeCoin(symbol) {
    selectedCoins.delete(symbol);
    if (tomSelect) {
        tomSelect.removeItem(symbol);
    }
    renderCoinSettings();
}

function updateCoinSetting(symbol, key, value) {
    if (selectedCoins.has(symbol)) {
        selectedCoins.get(symbol)[key] = value;
        renderCoinSettings();
    }
}

function renderCoinSettings() {
    const container = document.getElementById('coin_settings_container');
    container.innerHTML = '';

    if (selectedCoins.size === 0) {
        container.innerHTML = '<p class="small" style="text-align: center;">No coins selected yet.</p>';
    } else {
        selectedCoins.forEach(coin => {
            const estCost = (coin.leverage > 0) ? (coin.margin / coin.leverage).toFixed(2) : "0.00";
            const card = el('div', { class: 'bot-card' });
            card.style.marginBottom = '10px';
            card.innerHTML = `
                <div class="row" style="justify-content: space-between;">
                    <div><b>${coin.symbol}</b><div class="small mt">Price: <b>${typeof coin.price === 'number' ? coin.price.toFixed(4) : coin.price}</b></div></div>
                    <button class="btn btn-tiny-danger" data-symbol="${coin.symbol}">&times;</button>
                </div>
                <div class="row mt">
                    <div style="flex:1;"><label class="small">Leverage</label><input type="number" class="input input-small" value="${coin.leverage}" data-symbol="${coin.symbol}" data-key="leverage"></div>
                    <div style="flex:1;"><label class="small">Amount (USDT)</label><input type="number" class="input input-small" value="${coin.margin}" data-symbol="${coin.symbol}" data-key="margin"></div>
                </div>
                <div class="small mt">Margin / Cost: <b>${estCost} USDT</b></div>`;
            container.appendChild(card);
        });
    }

    let totalCost = 0;
    selectedCoins.forEach(c => { if (c.leverage > 0) totalCost += (c.margin / c.leverage); });
    document.getElementById('total_est_cost').textContent = `${totalCost.toFixed(2)} USDT`;
    document.getElementById('coin_count_display').textContent = selectedCoins.size;
}

// --- WebSocket Logic for Real-time ROI ---
function connectWebSocket(accountId) {
    if (socket && socket.connected) {
        socket.disconnect();
    }

    socket = io('/trades');

    socket.on('connect', () => {
        console.log('WebSocket Connected!');
        document.getElementById('ws_status').className = 'status-ok';
        document.getElementById('ws_status').textContent = 'Live';
        socket.emit('start_roi_updates', { account_id: accountId });
        socket.emit('request_initial_positions', { account_id: accountId });
    });

    socket.on('disconnect', () => {
        console.log('WebSocket Disconnected!');
        document.getElementById('ws_status').className = 'status-warn';
        document.getElementById('ws_status').textContent = 'Offline';
    });

    socket.on('positions_update', (data) => {
        runningTrades.clear();
        if (data.trades) {
            data.trades.forEach(trade => {
                trade.roi = 0; // Initial ROI
                runningTrades.set(trade.symbol, trade);
            });
        }
        renderRunningTrades();
    });

    socket.on('roi_update', (data) => {
        if (runningTrades.has(data.symbol)) {
            const trade = runningTrades.get(data.symbol);
            const entry = trade.entry_price;
            const mark = data.mark_price;
            let roi = 0;
            if (entry > 0) {
                roi = ((mark - entry) / entry) * trade.leverage * 100;
                if (trade.side === 'SHORT') roi *= -1;
            }
            trade.roi = roi;
            updateTradeRow(trade);
        }
    });

    socket.on('worker_error', (data) => {
        showError(data.message, '#running-trade-error');
    });
}

// --- Main Initialization ---
async function initDashboard() {
    const r = await fetch('/api/futures/symbols');
    const d = await r.json();
    if (d.symbols) {
        symbolsCache = d.symbols.map(s => ({value: s, text: s}));
    }

    tomSelect = new TomSelect('#coin_search_input', {
        options: symbolsCache,
        create: false,
        onItemAdd: function(value){
            addCoin(value);
        },
        onItemRemove: function(value){
            removeCoin(value);
        }
    });

    const settingsContainer = document.getElementById('coin_settings_container');
    settingsContainer.addEventListener('click', (e) => { if (e.target.classList.contains('btn-tiny-danger')) removeCoin(e.target.dataset.symbol); });
    settingsContainer.addEventListener('input', (e) => {
        if (e.target.classList.contains('input-small')) {
            const { symbol, key } = e.target.dataset;
            updateCoinSetting(symbol, key, isNaN(parseFloat(e.target.value)) ? 0 : parseFloat(e.target.value));
        }
    });

    document.getElementById('btn_submit_trade').addEventListener('click', submitTrade);
    document.getElementById('bot_account').addEventListener('change', (e) => {
        const accountId = e.target.value;
        if (accountId) {
            connectWebSocket(accountId);
        } else if (socket) {
            socket.disconnect();
            runningTrades.clear();
            renderRunningTrades();
        }
    });

    document.getElementById('roi_search_input').addEventListener('input', renderRunningTrades);
    document.getElementById('btn_close_selected').addEventListener('click', closeSelectedTrades);
    document.getElementById('btn_close_all').addEventListener('click', closeAllTrades);

    document.querySelector('.collapsible').addEventListener('click', function() {
        this.classList.toggle('active');
        this.nextElementSibling.style.display = this.nextElementSibling.style.display === "block" ? "none" : "block";
    });

    loadTemplates();
    document.getElementById('btn_save_template').addEventListener('click', saveTemplate);
    document.getElementById('tpl_list').addEventListener('click', handleTemplateAction);
}

async function submitTrade() {
    const payload = {
        bot_name: document.getElementById('bot_name').value.trim(),
        account_id: document.getElementById('bot_account').value,
        coins: []
    };
    const side = document.getElementById('trade_side').value;
    const margin_mode = document.getElementById('margin_mode').value;
    if (!payload.bot_name || !payload.account_id || selectedCoins.size === 0) return showError('Bot Name, Account, and at least one Coin are required.');

    selectedCoins.forEach(coin => payload.coins.push({ symbol: coin.symbol, side, leverage: coin.leverage, margin: coin.margin, margin_mode }));
    const btn = document.getElementById('btn_submit_trade');
    btn.disabled = true; btn.textContent = 'Submitting...';
    try {
        const r = await fetch('/api/trades/submit', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const res = await r.json();
        if (r.ok) {
            alert(res.message);
            selectedCoins.clear(); renderCoinSettings();
        } else {
            showError(res.error || 'An unknown error occurred.');
        }
    } catch(e) { showError('A network error occurred.'); }
    finally { btn.disabled = false; btn.textContent = 'Submit Trade'; }
}

// --- Running Trades Rendering ---
function renderRunningTrades() {
    const container = document.getElementById('running_trades_container');
    const roiFilter = parseFloat(document.getElementById('roi_search_input').value) || null;
    let matchCount = 0;

    const tradesToRender = Array.from(runningTrades.values()).filter(trade => {
        const passesFilter = roiFilter === null || trade.roi >= roiFilter;
        if (passesFilter) matchCount++;
        return passesFilter;
    });

    document.getElementById('roi_match_count').textContent = matchCount;

    if (tradesToRender.length > 0) {
        container.innerHTML = `
            <table class="trade-table">
                <thead><tr><th><input type="checkbox" id="select_all_trades"></th><th>Coin</th><th>Entry Price</th><th>ROI%</th><th>Side</th><th>Action</th></tr></thead>
                <tbody>${tradesToRender.map(trade => getTradeRowHTML(trade)).join('')}</tbody>
            </table>`;
        document.getElementById('select_all_trades').addEventListener('change', (e) => {
            document.querySelectorAll('.trade-checkbox').forEach(cb => cb.checked = e.target.checked);
        });
        container.addEventListener('click', (e) => {
            if (e.target.classList.contains('close-single-trade')) {
                const { symbol, side } = e.target.dataset;
                if(confirm(`Close ${symbol} ${side} trade?`)) closeTrades([{ symbol, side }]);
            }
        });
    } else {
        container.innerHTML = '<p class="small" style="text-align: center;">No running trades found for the selected criteria.</p>';
    }
}

function getTradeRowHTML(trade) {
    const roiClass = trade.roi >= 0 ? 'roi-pos' : 'roi-neg';
    return `
        <tr id="trade-row-${trade.symbol}">
            <td><input type="checkbox" class="trade-checkbox" data-symbol="${trade.symbol}" data-side="${trade.side}"></td>
            <td><b>${trade.symbol}</b></td>
            <td>${trade.entry_price.toFixed(4)}</td>
            <td><b class="${roiClass}" id="roi-${trade.symbol}">${trade.roi.toFixed(2)}%</b></td>
            <td>${trade.side}</td>
            <td><button class="btn-tiny-danger close-single-trade" data-symbol="${trade.symbol}" data-side="${trade.side}">&times; Close</button></td>
        </tr>`;
}

function updateTradeRow(trade) {
    const roiEl = document.getElementById(`roi-${trade.symbol}`);
    if (roiEl) {
        roiEl.textContent = `${trade.roi.toFixed(2)}%`;
        roiEl.className = trade.roi >= 0 ? 'roi-pos' : 'roi-neg';
    }
}

async function closeTrades(tradesToClose) {
    const account_id = document.getElementById('bot_account').value;
    if (!account_id || tradesToClose.length === 0) return;
    const r = await fetch('/api/trades/close', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ account_id, trades: tradesToClose }) });
    const res = await r.json();
    alert(res.message);
}

function closeSelectedTrades() {
    const trades = Array.from(document.querySelectorAll('.trade-checkbox:checked')).map(cb => ({ symbol: cb.dataset.symbol, side: cb.dataset.side }));
    if (trades.length > 0 && confirm(`Close ${trades.length} selected trades?`)) closeTrades(trades);
}

function closeAllTrades() {
    const trades = Array.from(document.querySelectorAll('.trade-checkbox')).map(cb => ({ symbol: cb.dataset.symbol, side: cb.dataset.side }));
    if (trades.length > 0 && confirm(`Close all ${trades.length} listed trades?`)) closeTrades(trades);
}

// --- Template Logic ---
async function saveTemplate() {
    const name = document.getElementById('bot_name').value.trim();
    if (!name || selectedCoins.size === 0) return showError('Template Name and at least one Coin are required.');
    const settings = {
        bot_name: name,
        side: document.getElementById('trade_side').value,
        margin_mode: document.getElementById('margin_mode').value,
        coins: Array.from(selectedCoins.values())
    };
    await fetch('/api/templates/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name, settings }) });
    loadTemplates();
}

async function loadTemplates() {
    const r = await fetch('/api/templates/list');
    const data = await r.json();
    const container = document.getElementById('tpl_list');
    container.innerHTML = '';
    if (data.items) {
        data.items.forEach(tpl => {
            const item = el('div', { class: 'list-item' });
            item.innerHTML = `
                <div><div class="name">${tpl.name}</div><div class="small">${new Date(tpl.created_at * 1000).toLocaleString()}</div></div>
                <div class="row"><button class="btn" data-id="${tpl.id}" data-action="edit"><i class="fas fa-edit"></i></button><button class="btn btn-danger" data-id="${tpl.id}" data-action="delete"><i class="fas fa-trash-alt"></i></button></div>`;
            container.appendChild(item);
        });
    }
}

async function handleTemplateAction(e) {
    const button = e.target.closest('button');
    if (!button) return;
    const { id, action } = button.dataset;

    if (action === 'delete') {
        if (confirm('Delete this template?')) {
            await fetch(`/api/templates/delete/${id}`, { method: 'POST' });
            loadTemplates();
        }
    } else if (action === 'edit') {
        const r = await fetch(`/api/templates/get/${id}`);
        const settings = await r.json();
        document.getElementById('bot_name').value = settings.bot_name;
        document.getElementById('trade_side').value = settings.side;
        document.getElementById('margin_mode').value = settings.margin_mode;
        selectedCoins.clear();
        tomSelect.clear();
        settings.coins.forEach(coin => {
            selectedCoins.set(coin.symbol, coin);
            tomSelect.addItem(coin.symbol);
        });
        renderCoinSettings();
    }
}